# Advanced/Queue - I

## Files in this topic:

- [N integers containing only 1, 2 & 3.py](N integers containing only 1, 2 & 3.py)
- [Perfect Numbers.py](Perfect Numbers.py)
- [Queues..pdf](Queues..pdf)
- [Reversing Elements Of Queue.py](Reversing Elements Of Queue.py)
- [Task Scheduling.py](Task Scheduling.py)

## Description

This section introduces the Queue data structure, a First-In-First-Out (FIFO) linear data structure. It covers basic queue operations (enqueue, dequeue, peek), implementations, and common problems solved using queues, such as level-order traversal in trees, or managing tasks.

### Pseudocode for N integers containing only 1, 2 & 3.py
```pseudocode
// Assumes Deque data structure with operations:
//   ADD_TO_END (enqueue), POP_FROM_FRONT (dequeue), IS_EMPTY.

FUNCTION generate_first_A_numbers_with_digits_123(A_count):
  // `result_list` will store the generated numbers.
  result_list = empty list

  // If A_count is 0, no numbers are needed.
  IF A_count == 0 THEN
    RETURN result_list
  ENDIF

  // `generation_queue` is used to generate numbers in increasing order using BFS-like approach.
  generation_queue = new Deque()

  // Initialize the queue with the first set of single-digit numbers (1, 2, 3).
  // These are added in order to ensure they are processed and added to `result_list` in order.
  generation_queue.ADD_TO_END(1)
  generation_queue.ADD_TO_END(2)
  generation_queue.ADD_TO_END(3)

  // Continue as long as the queue has numbers to process.
  // The loop will effectively stop once `A_count` numbers are collected due to the return condition inside.
  WHILE generation_queue IS NOT EMPTY:
    // Dequeue the smallest/earliest generated number not yet processed.
    current_base_number = generation_queue.POP_FROM_FRONT()

    // Add `current_base_number` to the result list if we haven't collected `A_count` numbers yet.
    // Python code logic: `if len(ans) != A: ans.append(d) else: return ans`
    // This means `d` is added, and only on the *next* iteration's check of `len(ans) == A` does it return.
    // So, we add `current_base_number` first.
    IF length of result_list < A_count THEN
      ADD current_base_number TO result_list
    ENDIF

    // If `A_count` numbers have been collected, return the result.
    IF length of result_list == A_count THEN
      RETURN result_list
    ENDIF

    // Generate new numbers by appending digits 1, 2, and 3 to `current_base_number`.
    // Enqueue these new numbers. They will be processed later in increasing order.
    // This ensures that if we need more numbers, we explore from the current smallest ones.

    new_num_ending_in_1 = current_base_number * 10 + 1
    generation_queue.ADD_TO_END(new_num_ending_in_1)

    new_num_ending_in_2 = current_base_number * 10 + 2
    generation_queue.ADD_TO_END(new_num_ending_in_2)

    new_num_ending_in_3 = current_base_number * 10 + 3
    generation_queue.ADD_TO_END(new_num_ending_in_3)
  ENDWHILE

  // This part would only be reached if the queue becomes empty before `A_count` numbers are found
  // (e.g. if A_count is extremely large, exceeding practical number limits, though not typical for this problem).
  RETURN result_list
ENDFUNCTION
```

### Pseudocode for Perfect Numbers.py
```pseudocode
// Assumes Deque data structure with operations:
//   ADD_TO_END (enqueue), POP_FROM_FRONT (dequeue), IS_EMPTY.
// Assumes string operations: LENGTH, SUBSTRING, CONCATENATION.

FUNCTION find_Ath_special_perfect_number_string(A_target_index):
  // "Perfect numbers" here are palindromic strings made of '1's and '2's,
  // generated by inserting "11" or "22" in the middle of existing ones.

  // Handle invalid A_target_index (e.g., non-positive).
  IF A_target_index <= 0 THEN
    RETURN "" // Or appropriate error/default value
  ENDIF

  // `processing_deque` stores perfect number strings in the order they are generated.
  processing_deque = new Deque()

  // Initialize the deque with the first two perfect numbers in the sequence.
  processing_deque.ADD_TO_END("11") // 1st perfect number
  processing_deque.ADD_TO_END("22") // 2nd perfect number

  perfect_numbers_generated_count = 0

  // Loop until the A_target_index-th perfect number is found.
  WHILE processing_deque IS NOT EMPTY: // Should always find if A_target_index is reachable
    // Get the next perfect number string from the front of the deque.
    current_perfect_string = processing_deque.POP_FROM_FRONT()

    perfect_numbers_generated_count = perfect_numbers_generated_count + 1

    // Check if this is the A_target_index-th perfect number.
    IF perfect_numbers_generated_count == A_target_index THEN
      RETURN current_perfect_string
    ENDIF

    // Generate two new perfect numbers from current_perfect_string:
    // Insert "11" in the middle and "22" in the middle.
    len_current_str = LENGTH(current_perfect_string)
    mid_point_idx = len_current_str / 2 // Integer division gives the insertion index

    first_part = SUBSTRING of current_perfect_string from index 0 up to (mid_point_idx - 1)
    second_part = SUBSTRING of current_perfect_string from index mid_point_idx to end

    // New number by inserting "11"
    new_num_insert_11 = first_part + "11" + second_part
    processing_deque.ADD_TO_END(new_num_insert_11)

    // New number by inserting "22"
    new_num_insert_22 = first_part + "22" + second_part
    processing_deque.ADD_TO_END(new_num_insert_22)
  ENDWHILE

  // This part should ideally not be reached if A_target_index is valid and generation is infinite.
  // Could indicate A_target_index was too large for practical computation or an error.
  RETURN "" // Or error
ENDFUNCTION
```

### Pseudocode for Reversing Elements Of Queue.py
```pseudocode
// Assumes Deque data structure that can function as both a Queue and a Stack.
// Queue operations: ENQUEUE (add to rear), DEQUEUE (remove from front).
// Stack operations: PUSH (add to top), POP (remove from top).
// Python's `collections.deque` supports these: `append` (enqueue/push), `popleft` (dequeue), `pop` (pop from stack).

FUNCTION reverse_first_B_elements_in_queue(A_initial_list_elements, B_num_elements_to_reverse):
  // Initialize the main queue with elements from A_initial_list_elements.
  main_processing_queue = new Deque()
  FOR EACH item IN A_initial_list_elements:
    main_processing_queue.ENQUEUE(item)
  ENDFOR

  // `temp_storage_stack` is used to hold the first B elements in reverse order temporarily.
  temp_storage_stack = new Deque() // Using deque as a stack

  // `final_result_queue` will store the elements in their final order.
  final_result_queue = new Deque()

  // Step 1: Dequeue the first B_num_elements_to_reverse (or fewer if queue is smaller)
  // from `main_processing_queue` and push them onto `temp_storage_stack`.
  num_to_move_to_stack = minimum(B_num_elements_to_reverse, GET_SIZE(main_processing_queue))
  FOR _ FROM 1 TO num_to_move_to_stack:
    IF main_processing_queue IS NOT EMPTY THEN // Should be true given num_to_move_to_stack calculation
      element = main_processing_queue.DEQUEUE()
      temp_storage_stack.PUSH(element)
    ENDIF
  ENDFOR

  // Step 2: Pop elements from `temp_storage_stack` and enqueue them into `final_result_queue`.
  // This effectively adds the first B (or fewer) elements in reversed order to the result.
  WHILE temp_storage_stack IS NOT EMPTY:
    element = temp_storage_stack.POP()
    final_result_queue.ENQUEUE(element)
  ENDFOR

  // Step 3: Enqueue any remaining elements from `main_processing_queue` into `final_result_queue`.
  // These elements were beyond the first B and remain in their original relative order.
  WHILE main_processing_queue IS NOT EMPTY:
    element = main_processing_queue.DEQUEUE()
    final_result_queue.ENQUEUE(element)
  ENDFOR

  // Convert final_result_queue (which is a Deque) to a list for the return value.
  RETURN convert_deque_to_list(final_result_queue)
ENDFUNCTION
```

### Pseudocode for Task Scheduling.py
```pseudocode
// Assumes Deque data structure with operations:
//   INITIALIZE_FROM_LIST(deque, list)
//   ADD_TO_END(deque, item)   (enqueue)
//   POP_FROM_FRONT(deque) (dequeue)
//   PEEK_FRONT(deque)     (get front element without removing)
//   IS_EMPTY(deque)

FUNCTION calculate_total_task_scheduling_time(A_initial_task_queue_order, B_desired_execution_order):
  total_elapsed_time = 0

  // Create a queue representing the current order of tasks.
  task_processing_queue = new Deque()
  INITIALIZE_FROM_LIST(task_processing_queue, A_initial_task_queue_order)

  // Process each task in the desired execution order.
  FOR EACH target_task IN B_desired_execution_order:
    // If the queue becomes empty but there are still tasks in B_desired_execution_order,
    // it implies an inconsistency (e.g., B contains tasks not in A).
    // Assuming valid inputs where all tasks in B are present in A initially.
    IF task_processing_queue.IS_EMPTY() THEN
      // This state should ideally not be reached if inputs are consistent.
      BREAK FOR // Stop processing if queue is unexpectedly empty.
    ENDIF

    // Phase 1: Rotate tasks in the queue until the `target_task` is at the front.
    // Each rotation (moving the front task to the back) costs 1 unit of time.
    WHILE task_processing_queue.PEEK_FRONT() != target_task:
      total_elapsed_time = total_elapsed_time + 1 // Cost of rotation

      task_to_rotate = task_processing_queue.POP_FROM_FRONT()
      task_processing_queue.ADD_TO_END(task_to_rotate)

      // Safety break if queue becomes empty during rotation (should not happen if target is present).
      IF task_processing_queue.IS_EMPTY() THEN BREAK WHILE ENDIF
    ENDWHILE

    // Phase 2: Execute the `target_task` (now at the front of the queue).
    // This costs 1 unit of time.
    // Ensure the task is indeed at the front (it should be if loop above exited normally).
    IF task_processing_queue.IS_EMPTY() IS FALSE AND task_processing_queue.PEEK_FRONT() == target_task THEN
      total_elapsed_time = total_elapsed_time + 1 // Cost of execution
      task_processing_queue.POP_FROM_FRONT()      // Remove executed task from queue
    ELSE
      // This implies target_task was not found, or queue became empty.
      // Based on problem, this should not happen if B is a permutation of A.
    ENDIF
  ENDFOR

  RETURN total_elapsed_time
ENDFUNCTION
```
