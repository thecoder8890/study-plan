# Advanced/Recursion - II

## Files in this topic:

- [A1.py](A1.py)
- [A2.py](A2.py)
- [Adv_Recursion_II.pdf](Adv_Recursion_II.pdf)
- [HW1.py](HW1.py)

## Description

This section explores more advanced topics and applications of Recursion. It likely covers more complex recursive structures, divide and conquer strategies, and problems where the recursive formulation is non-trivial.

### Pseudocode for A1.py
```pseudocode
// This class provides a solution to the Tower of Hanoi puzzle,
// generating a list of moves required.

CLASS Solution_TowerOfHanoi:
  // An attribute to store the sequence of moves.
  // Each move is represented as a list: [disk_number, source_peg, destination_peg].
  // This list is populated by the recursive utility function.
  moves_list_accumulator: List of Lists of Integers

  // Main public function that initiates the Tower of Hanoi solution.
  // A_num_disks_to_move_initially: The total number of disks.
  // Pegs are conventionally numbered 1 (source), 2 (auxiliary), 3 (destination).
  FUNCTION towerOfHanoi(A_num_disks_to_move_initially):
    // Initialize or clear the list that will store the moves for the current call.
    this.moves_list_accumulator = new empty List

    // Start the recursive process: move A_num_disks_to_move_initially disks
    // from peg 1 (source) to peg 3 (destination), using peg 2 (auxiliary).
    this.towerOfHanoi_recursive_helper(A_num_disks_to_move_initially, 1, 3, 2)

    RETURN this.moves_list_accumulator
  ENDFUNCTION

  // Recursive helper function for the Tower of Hanoi problem.
  // Moves `current_num_disks` from `peg_from` to `peg_to` using `peg_aux`.
  DEFINE FUNCTION towerOfHanoi_recursive_helper(current_num_disks, peg_from, peg_to, peg_aux):
    // Base Case: If there are no disks to move (current_num_disks is 0), do nothing.
    IF current_num_disks == 0 THEN
      RETURN
    ENDIF

    // Step 1: Move `current_num_disks - 1` disks from `peg_from` to `peg_aux`,
    // using `peg_to` as the auxiliary peg for this sub-move.
    this.towerOfHanoi_recursive_helper(current_num_disks - 1, peg_from, peg_aux, peg_to)

    // Step 2: Move the current largest disk (disk number `current_num_disks`)
    // from `peg_from` to `peg_to`. Record this move.
    ADD [current_num_disks, peg_from, peg_to] TO this.moves_list_accumulator

    // Step 3: Move the `current_num_disks - 1` disks (now on `peg_aux`)
    // from `peg_aux` to `peg_to`, using `peg_from` as the auxiliary peg for this sub-move.
    this.towerOfHanoi_recursive_helper(current_num_disks - 1, peg_aux, peg_to, peg_from)
  ENDFUNCTION
ENDCLASS
```

### Pseudocode for HW1.py
```pseudocode
// This class implements a recursive solution to find the B-th symbol in the A-th row
// of a sequence generated by: Row 1 is "0", Row K = (Row K-1) + (Flipped bits of Row K-1).

CLASS Solution_KthSymbolInGrammarRecursive:

  // Main function called externally.
  // A_row_level: The level (row number, 1-based) in the sequence generation.
  // B_symbol_index: The 1-based index of the symbol to find at that level.
  FUNCTION solve_kth_symbol_main(A_row_level, B_symbol_index):
    // Delegates to the recursive helper function.
    RETURN this.find_recursive_symbol_at_level_index(A_row_level, B_symbol_index)
  ENDFUNCTION

  // Recursive helper function.
  DEFINE FUNCTION find_recursive_symbol_at_level_index(current_level, k_index_1_based):
    // Base Case: At Level 1, the sequence is "0". The only valid k_index_1_based is 1.
    IF current_level == 1 THEN
      RETURN 0
    ENDIF

    // Recursive Step:
    // The symbol at (current_level, k_index_1_based) depends on a symbol in the previous level (current_level - 1).
    // The length of the sequence at (current_level - 1) is 2^(current_level - 2).
    // The index in the parent level is found by `(k_index_1_based + 1) / 2`.
    // This maps pairs of indices (1,2) in current level to index 1 in parent, (3,4) to 2, etc.
    index_in_parent_level = (k_index_1_based + 1) / 2 // Integer division

    symbol_from_parent = this.find_recursive_symbol_at_level_index(current_level - 1, index_in_parent_level)

    // Determine if k_index_1_based is in the first half (copied part) or second half (flipped part)
    // of the sequence at current_level.
    // If k_index_1_based is odd, it's from the first half (direct copy from parent).
    // If k_index_1_based is even, it's from the second half (flipped copy from parent).
    IF k_index_1_based MOD 2 == 1 THEN // Odd index: corresponds to non-flipped part
      RETURN symbol_from_parent
    ELSE // Even index: corresponds to flipped part
      RETURN 1 XOR symbol_from_parent // XOR with 1 flips the bit (0 becomes 1, 1 becomes 0)
    ENDIF
  ENDFUNCTION
ENDCLASS
```

### Pseudocode for A2.py
```pseudocode
// This class generates Gray codes using a recursive construction method.
// An iterative method using the formula (i XOR (i>>1)) is also present in the Python file but not detailed here.

CLASS Solution_RecursiveGrayCode:
  // `generated_gray_codes_list` stores the sequence of Gray codes.
  // This is treated as an instance variable, modified by the recursive helper.
  ATTRIBUTE generated_gray_codes_list: List of Integers

  // Main function to generate Gray codes for `A_bits` number of bits.
  FUNCTION grayCode(A_bits):
    // Initialize/reset the list for the current computation.
    this.generated_gray_codes_list = new empty List

    // Call the recursive helper function to populate the list.
    this.generate_gray_codes_recursive_step(A_bits)

    RETURN this.generated_gray_codes_list
  ENDFUNCTION

  // Recursive helper function.
  // `num_bits_current_level` is the number of bits for which Gray codes are being generated.
  DEFINE FUNCTION generate_gray_codes_recursive_step(num_bits_current_level):
    // Base Case: For 0 bits, the Gray code sequence is defined as [0].
    // This helps in building up: G(1) from G(0) will be [0, 0|1] = [0,1].
    IF num_bits_current_level == 0 THEN
      ADD 0 TO this.generated_gray_codes_list
      RETURN
    ENDIF

    // Step 1: Recursively generate Gray codes for (num_bits_current_level - 1).
    // These (n-1)-bit codes are now in `this.generated_gray_codes_list`.
    this.generate_gray_codes_recursive_step(num_bits_current_level - 1)

    // Step 2: Construct the second half of the n-bit Gray codes.
    // These are formed by taking the (n-1)-bit codes (already in the list)
    // in reverse order and prefixing each with a '1'.

    count_of_n_minus_1_bit_codes = length of this.generated_gray_codes_list

    // The mask for the new most significant bit (MSB) for n-bit codes.
    // This is 2^(num_bits_current_level - 1).
    msb_value_mask = 1 LEFT_SHIFT (num_bits_current_level - 1)

    // Iterate through the existing (n-1)-bit Gray codes in reverse order.
    FOR i FROM count_of_n_minus_1_bit_codes - 1 DOWNTO 0:
      // Get an (n-1)-bit Gray code from the first half of the list (which was generated recursively).
      previous_level_gray_code = this.generated_gray_codes_list[i]
      // Create a new n-bit Gray code by ORing with the msb_value_mask (effectively prepending a '1').
      new_n_bit_gray_code = previous_level_gray_code OR msb_value_mask
      // Add this new code to the end of the list.
      ADD new_n_bit_gray_code TO this.generated_gray_codes_list
    ENDFOR
  ENDFUNCTION
ENDCLASS
```

### Pseudocode for A1.py
```pseudocode
// This class provides a solution to the Tower of Hanoi puzzle,
// generating a list of moves required.

CLASS Solution_TowerOfHanoi:
  // An attribute to store the sequence of moves.
  // Each move is represented as a list: [disk_number, source_peg, destination_peg].
  // This list is populated by the recursive utility function.
  moves_list_accumulator: List of Lists of Integers

  // Main public function that initiates the Tower of Hanoi solution.
  // A_num_disks_to_move_initially: The total number of disks.
  // Pegs are conventionally numbered 1 (source), 2 (auxiliary), 3 (destination).
  FUNCTION towerOfHanoi(A_num_disks_to_move_initially):
    // Initialize or clear the list that will store the moves for the current call.
    this.moves_list_accumulator = new empty List

    // Start the recursive process: move A_num_disks_to_move_initially disks
    // from peg 1 (source) to peg 3 (destination), using peg 2 (auxiliary).
    this.towerOfHanoi_recursive_helper(A_num_disks_to_move_initially, 1, 3, 2)

    RETURN this.moves_list_accumulator
  ENDFUNCTION

  // Recursive helper function for the Tower of Hanoi problem.
  // Moves `current_num_disks` from `peg_from` to `peg_to` using `peg_aux`.
  DEFINE FUNCTION towerOfHanoi_recursive_helper(current_num_disks, peg_from, peg_to, peg_aux):
    // Base Case: If there are no disks to move (current_num_disks is 0), do nothing.
    IF current_num_disks == 0 THEN
      RETURN
    ENDIF

    // Step 1: Move `current_num_disks - 1` disks from `peg_from` to `peg_aux`,
    // using `peg_to` as the auxiliary peg for this sub-move.
    this.towerOfHanoi_recursive_helper(current_num_disks - 1, peg_from, peg_aux, peg_to)

    // Step 2: Move the current largest disk (disk number `current_num_disks`)
    // from `peg_from` to `peg_to`. Record this move.
    ADD [current_num_disks, peg_from, peg_to] TO this.moves_list_accumulator

    // Step 3: Move the `current_num_disks - 1` disks (now on `peg_aux`)
    // from `peg_aux` to `peg_to`, using `peg_from` as the auxiliary peg for this sub-move.
    this.towerOfHanoi_recursive_helper(current_num_disks - 1, peg_aux, peg_to, peg_from)
  ENDFUNCTION
ENDCLASS
```
